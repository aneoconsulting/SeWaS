/*
  SeWaS
  Copyright (C) 2018  ANEO

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
==============================================================================*/

extern "C" %{
  /* Prototypes of the wrappers to be called by PaRSEC' tasks */
  typedef void (*initializeFields_t   )(const int ii, const int jj, const int kk);

  typedef int  (*computeVelocity_t    )(const int d,  const int ts, const int ii, const int jj, const int kk);
  typedef void (*extractVelocityHalo_t)(const int l, const int d,  const int ts, const int ii, const int jj, const int kk, void * vH);
  typedef void (*updateVelocity_t     )(const int l, const int d,  const int ts, const int ii, const int jj, const int kk, void * vH);

  typedef int  (*computeStress_t      )(const int sc, const int ts, const int ii, const int jj, const int kk);
  typedef void (*extractStressHalo_t  )(const int l, const int sc, const int ts, const int ii, const int jj, const int kk, void * sigmaH);
  typedef void (*updateStress_t       )(const int l, const int sc, const int ts, const int ii, const int jj, const int kk, void * sigmaH);

  typedef void (*displayVelocity_t    )(const int d,  const int ts, const int ii, const int jj, const int kk, const int tid);
  typedef void (*displayStress_t      )(const int sc, const int ts, const int ii, const int jj, const int kk, const int tid);

  /* Reflections of enums defined in Config.hxx */
  enum {_X, _Y, _Z, _DIM};
  enum {_XX, _YY, _ZZ, _XY, _XZ, _YZ, _NB_STRESS_FIELD_COMPONENTS};
  enum {_LEFT, _RIGHT, _BACKWARD, _FORWARD, _BOTTOM, _TOP, _NB_LOCATIONS};
%}



/* Directions */
X				[type = "int" hidden = on default = _X]
Y				[type = "int" hidden = on default = _Y]
Z				[type = "int" hidden = on default = _Z]
DIM				[type = "int" hidden = on default = _DIM]


/* Stress Field Components */
XX				[type = "int" hidden = on default = _XX]
YY				[type = "int" hidden = on default = _YY]
ZZ				[type = "int" hidden = on default = _ZZ]
XY				[type = "int" hidden = on default = _XY]
XZ				[type = "int" hidden = on default = _XZ]
YZ				[type = "int" hidden = on default = _YZ]
NB_STRESS_FIELD_COMPONENTS	[type = "int" hidden = on default = _NB_STRESS_FIELD_COMPONENTS]

/* Locations */
LEFT				[type = "int" hidden = on default = _LEFT]
RIGHT				[type = "int" hidden = on default = _RIGHT]
BACKWARD			[type = "int" hidden = on default = _BACKWARD]
FORWARD				[type = "int" hidden = on default = _FORWARD]
BOTTOM				[type = "int" hidden = on default = _BOTTOM]
TOP				[type = "int" hidden = on default = _TOP]
NB_LOCATIONS            	[type = "int" hidden = on default = _NB_LOCATIONS]


dim				[type = "int" hidden = on default = _DIM]				/* Dimension */
nsc				[type = "int" hidden = on default = _NB_STRESS_FIELD_COMPONENTS]	/* Number of stress field components */
nl				[type = "int" hidden = on default = _NB_LOCATIONS]			/* Total number of neighbours per domain */



/* Parameters to be passed to the PaRSEC context */
nt				[type = "int"]								/* Number of time steps */
nxx				[type = "int"]								/* Total number of blocks along x axis */
nyy				[type = "int"]								/* Total number of blocks along y axis */
nzz				[type = "int"]								/* Total number of blocks along z axis */

initializeFields                [type = "void *"]

computeVelocity			[type = "void *"]
extractVelocityHalo		[type = "void *"]
updateVelocity		        [type = "void *"]

computeStress			[type = "void *"]
extractStressHalo		[type = "void *"]
updateStress		        [type = "void *"]

displayVelocity                 [type = "void *"]
displayStress                   [type = "void *"]

sewas_ddesc			[type = "parsec_data_collection_t *"]					/* Data descriptor */







InitializeFields(ii, jj, kk)

// Execution space
ii = 0 .. nxx-1
jj = 0 .. nyy-1
kk = 0 .. nzz-1


// Parallel partitioning
: sewas_ddesc(ii, jj, kk)


CTL I    -> I ComputeVelocity(0..dim-1, 2, ii, jj, kk)


BODY
{
#ifdef VERBOSE
  fprintf(stdout, "InitializeFields: %d, %d, %d\n", ii, jj, kk);
#endif

  ((initializeFields_t) initializeFields) (ii, jj, kk);

#ifdef VERBOSE
  fprintf(stdout, "InitializeFields -- Completed: %d, %d, %d\n", ii, jj, kk);
#endif
}
END



ComputeVelocity(d, ts, ii, jj, kk)

// Execution space
d  = 0 .. dim-1
ts = 2 .. nt-2 .. 2
ii = 0 .. nxx-1
jj = 0 .. nyy-1
kk = 0 .. nzz-1


// Parallel partitioning
: sewas_ddesc(ii, jj, kk)


// Data flow
CTL I    <- (ts == 2)                      ? I    InitializeFields(ii, jj, kk)

CTL SxxH <- ( d == X	        && ts > 2) ? SxxH UpdateStress(0..nl-1, XX, ts-1, ii, jj, kk)
CTL SyyH <- ( d == Y	        && ts > 2) ? SyyH UpdateStress(0..nl-1, YY, ts-1, ii, jj, kk)
CTL SzzH <- ( d == Z	        && ts > 2) ? SzzH UpdateStress(0..nl-1, ZZ, ts-1, ii, jj, kk)
CTL SxyH <- ((d == X || d == Y) && ts > 2) ? SxyH UpdateStress(0..nl-1, XY, ts-1, ii, jj, kk)
CTL SxzH <- ((d == X || d == Z) && ts > 2) ? SxzH UpdateStress(0..nl-1, XZ, ts-1, ii, jj, kk)
CTL SyzH <- ((d == Y || d == Z) && ts > 2) ? SyzH UpdateStress(0..nl-1, YZ, ts-1, ii, jj, kk)

CTL V    -> V ExtractVelocityHalo(0..nl-1, d, ts, ii, jj, kk)
         -> V DisplayVelocity(d, ts, ii, jj, kk)

BODY
{
#ifdef VERBOSE
  fprintf(stdout, "ComputeVelocity: %d, %d, %d, %d, %d\n", d, ts, ii, jj, kk);
#endif

  ((computeVelocity_t) computeVelocity) (d, ts, ii, jj, kk);

#ifdef VERBOSE
  fprintf(stdout, "ComputeVelocity -- Completed: %d, %d, %d, %d, %d\n", d, ts, ii, jj, kk);
#endif
}
END



ExtractVelocityHalo(l, d, ts, ii, jj, kk)

// Execution space
l  = 0 .. nl-1
d  = 0 .. dim-1
ts = 2 .. nt-2 .. 2
ii = 0 .. nxx-1
jj = 0 .. nyy-1
kk = 0 .. nzz-1


// Parallel partitioning
: sewas_ddesc(ii, jj, kk)


// Data flow
CTL V           <- V ComputeVelocity(d, ts, ii, jj, kk)
                -> V UpdateVelocity(l, d, ts, ii, jj, kk) /* Extraction must occur before Update to avoid RAW issues */

// TODO it is enough to just create the halo at the begining of the simulation and reuse the buffers for subsequent iterations
WRITE VRight    -> (l == RIGHT    && ii < nxx-1) ? VLeft     UpdateVelocity(LEFT,     d, ts, ii+1, jj, kk) [type = VRIGHT_HALO]
WRITE VLeft     -> (l == LEFT     && ii > 0    ) ? VRight    UpdateVelocity(RIGHT,    d, ts, ii-1, jj, kk) [type = VLEFT_HALO]

WRITE VForward  -> (l == FORWARD  && jj < nyy-1) ? VBackward UpdateVelocity(BACKWARD, d, ts, ii, jj+1, kk) [type = VFORWARD_HALO]
WRITE VBackward -> (l == BACKWARD && jj > 0    ) ? VForward  UpdateVelocity(FORWARD,  d, ts, ii, jj-1, kk) [type = VBACKWARD_HALO]

WRITE VTop      -> (l == TOP      && kk < nzz-1) ? VBottom   UpdateVelocity(BOTTOM,   d, ts, ii, jj, kk+1) [type = VTOP_HALO]
WRITE VBottom   -> (l == BOTTOM   && kk > 0    ) ? VTop      UpdateVelocity(TOP,      d, ts, ii, jj, kk-1) [type = VBOTTOM_HALO]


BODY
{
  /* fprintf(stdout, "ExtractVelocityHalo(%d, %d, %d, %d, %d, %d)\n", l, d, ts, ii, jj, kk); */

  switch(l){
  case _LEFT:
    if (ii > 0){
      ((extractVelocityHalo_t) extractVelocityHalo) (l, d, ts, ii, jj, kk, VLeft);
    }
    break;
  case _RIGHT:
    if (ii < nxx-1){
      ((extractVelocityHalo_t) extractVelocityHalo) (l, d, ts, ii, jj, kk, VRight);
    }
    break;
  case _BACKWARD:
    if (jj > 0){
      ((extractVelocityHalo_t) extractVelocityHalo) (l, d, ts, ii, jj, kk, VBackward);
    }
    break;
  case _FORWARD:
    if (jj < nyy-1){
      ((extractVelocityHalo_t) extractVelocityHalo) (l, d, ts, ii, jj, kk, VForward);
    }
    break;
  case _BOTTOM:
    if (kk > 0){
      ((extractVelocityHalo_t) extractVelocityHalo) (l, d, ts, ii, jj, kk, VBottom);
    }
    break;
  case _TOP:
    if (kk < nzz-1){
      ((extractVelocityHalo_t) extractVelocityHalo) (l, d, ts, ii, jj, kk, VTop);
    }
    break;
  default:
    fprintf(stdout, "ExtractVelocityHalo(%d, %d, %d, %d, %d, %d) - Unknown location (%d)\n", l, d, ts, ii, jj, kk, l);
  }

  /* fprintf(stdout, "ExtractVelocityHalo(%d, %d, %d, %d, %d, %d) - Completed\n", l, d, ts, ii, jj, kk); */
}
END



UpdateVelocity(l, d, ts, ii, jj, kk)

// Execution space
l  = 0 .. nl-1
d  = 0 .. dim-1
ts = 2 .. nt-2 .. 2
ii = 0 .. nxx-1
jj = 0 .. nyy-1
kk = 0 .. nzz-1


// Parallel partitioning
: sewas_ddesc(ii, jj, kk)


// Data flow
READ VLeft      <-  (l == LEFT     && ii > 0    ) ? VRight    ExtractVelocityHalo(RIGHT, d, ts, ii-1, jj, kk)    [type = VLEFT_HALO]
                <- !(l == LEFT     && ii > 0    ) ? NULL
READ VRight     <-  (l == RIGHT    && ii < nxx-1) ? VLeft     ExtractVelocityHalo(LEFT,  d, ts, ii+1, jj, kk)    [type = VRIGHT_HALO]
                <- !(l == RIGHT    && ii < nxx-1) ? NULL

READ VBackward  <-  (l == BACKWARD && jj > 0    ) ? VForward  ExtractVelocityHalo(FORWARD,  d, ts, ii, jj-1, kk) [type = VBACKWARD_HALO]
                <- !(l == BACKWARD && jj > 0    ) ? NULL
READ VForward   <-  (l == FORWARD  && jj < nyy-1) ? VBackward ExtractVelocityHalo(BACKWARD, d, ts, ii, jj+1, kk) [type = VFORWARD_HALO]
                <- !(l == FORWARD  && jj < nyy-1) ? NULL

READ VBottom    <-  (l == BOTTOM   && kk > 0    ) ? VTop      ExtractVelocityHalo(TOP,    d, ts, ii, jj, kk-1)   [type = VBOTTOM_HALO]
                <- !(l == BOTTOM   && kk > 0    ) ? NULL
READ VTop       <-  (l == TOP      && kk < nzz-1) ? VBottom   ExtractVelocityHalo(BOTTOM, d, ts, ii, jj, kk+1)   [type = VTOP_HALO]
                <- !(l == TOP      && kk < nzz-1) ? NULL


CTL V           <- V ExtractVelocityHalo(l, d, ts, ii, jj, kk)


CTL VxH         -> (d == X) ? VxH ComputeStress(XX, ts+1, ii, jj, kk)
                -> (d == X) ? VxH ComputeStress(YY, ts+1, ii, jj, kk)
                -> (d == X) ? VxH ComputeStress(ZZ, ts+1, ii, jj, kk)
                -> (d == X) ? VxH ComputeStress(XY, ts+1, ii, jj, kk)
                -> (d == X) ? VxH ComputeStress(XZ, ts+1, ii, jj, kk)

CTL VyH         -> (d == Y) ? VyH ComputeStress(XX, ts+1, ii, jj, kk)
                -> (d == Y) ? VyH ComputeStress(YY, ts+1, ii, jj, kk)
                -> (d == Y) ? VyH ComputeStress(ZZ, ts+1, ii, jj, kk)
                -> (d == Y) ? VyH ComputeStress(XY, ts+1, ii, jj, kk)
                -> (d == Y) ? VyH ComputeStress(YZ, ts+1, ii, jj, kk)

CTL VzH         -> (d == Z) ? VzH ComputeStress(XX, ts+1, ii, jj, kk)
                -> (d == Z) ? VzH ComputeStress(YY, ts+1, ii, jj, kk)
                -> (d == Z) ? VzH ComputeStress(ZZ, ts+1, ii, jj, kk)
                -> (d == Z) ? VzH ComputeStress(XZ, ts+1, ii, jj, kk)
                -> (d == Z) ? VzH ComputeStress(YZ, ts+1, ii, jj, kk)

BODY
{
  /* fprintf(stdout, "UpdateVelocity(%d, %d, %d, %d, %d, %d)\n", l, d, ts, ii, jj, kk); */

  switch(l){
  case _LEFT:
    if (ii > 0){
      ((updateVelocity_t) updateVelocity) (l, d, ts, ii, jj, kk, VLeft);
    }
    break;
  case _RIGHT:
    if (ii < nxx-1){
      ((updateVelocity_t) updateVelocity) (l, d, ts, ii, jj, kk, VRight);
    }
    break;
  case _BACKWARD:
    if (jj > 0){
      ((updateVelocity_t) updateVelocity) (l, d, ts, ii, jj, kk, VBackward);
    }
    break;
  case _FORWARD:
    if (jj < nyy-1){
      ((updateVelocity_t) updateVelocity) (l, d, ts, ii, jj, kk, VForward);
    }
    break;
  case _BOTTOM:
    if (kk > 0){
      ((updateVelocity_t) updateVelocity) (l, d, ts, ii, jj, kk, VBottom);
    }
    break;
  case _TOP:
    if (kk < nzz-1){
      ((updateVelocity_t) updateVelocity) (l, d, ts, ii, jj, kk, VTop);
    }
    break;
  default:
    fprintf(stdout, "UpdateVelocity(%d, %d, %d, %d, %d, %d) - Unknown location\n", l, d, ts, ii, jj, kk);
  }

  /* fprintf(stdout, "UpdateVelocity(%d, %d, %d, %d, %d, %d) - Completed\n", l, d, ts, ii, jj, kk); */
}
END




ComputeStress(sc, ts, ii, jj, kk)

// Execution space
sc = 0 .. nsc-1
ts = 3 .. nt-1 .. 2
ii = 0 .. nxx-1
jj = 0 .. nyy-1
kk = 0 .. nzz-1


// Parallel partitioning
: sewas_ddesc(ii, jj, kk)


// Data flow
CTL VxH <- (sc == XX || sc == YY || sc == ZZ || sc == XY || sc == XZ) ? VxH UpdateVelocity(0..nl-1, X, ts-1, ii, jj, kk)
CTL VyH <- (sc == XX || sc == YY || sc == ZZ || sc == XY || sc == YZ) ? VyH UpdateVelocity(0..nl-1, Y, ts-1, ii, jj, kk)
CTL VzH <- (sc == XX || sc == YY || sc == ZZ || sc == XZ || sc == YZ) ? VzH UpdateVelocity(0..nl-1, Z, ts-1, ii, jj, kk)

CTL S   -> S ExtractStressHalo(0..nl-1, sc, ts, ii, jj, kk)
        -> S DisplayStress(sc, ts, ii, jj, kk)

BODY
{
#ifdef VERBOSE
  fprintf(stdout, "ComputeStress: %d, %d, %d, %d, %d\n", sc, ts, ii, jj, kk);
#endif

  ((computeStress_t) computeStress) (sc, ts, ii, jj, kk);

#ifdef VERBOSE
  fprintf(stdout, "ComputeStress -- Completed: %d, %d, %d, %d, %d\n", sc, ts, ii, jj, kk);
#endif
}
END


ExtractStressHalo(l, sc, ts, ii, jj, kk)

// Execution space
l  = 0 .. nl-1
sc = 0 .. nsc-1
ts = 3 .. nt-1 .. 2
ii = 0 .. nxx-1
jj = 0 .. nyy-1
kk = 0 .. nzz-1


// Parallel partitioning
: sewas_ddesc(ii, jj, kk)


// Data flow
CTL   S         <- S ComputeStress(sc, ts, ii, jj, kk)
                -> (ts < nt-1) ? S UpdateStress(l, sc, ts, ii, jj, kk) /* Extraction must occur before Update to avoid RAW issues */

WRITE SRight    -> (l == RIGHT    && ii < nxx-1 && ts < nt-1) ? SLeft     UpdateStress(LEFT,     sc, ts, ii+1, jj, kk) [type = SRIGHT_HALO]
WRITE SLeft     -> (l == LEFT     && ii > 0     && ts < nt-1) ? SRight    UpdateStress(RIGHT,    sc, ts, ii-1, jj, kk) [type = SLEFT_HALO]

WRITE SForward  -> (l == FORWARD  && jj < nyy-1 && ts < nt-1) ? SBackward UpdateStress(BACKWARD, sc, ts, ii, jj+1, kk) [type = SFORWARD_HALO]
WRITE SBackward -> (l == BACKWARD && jj > 0     && ts < nt-1) ? SForward  UpdateStress(FORWARD,  sc, ts, ii, jj-1, kk) [type = SBACKWARD_HALO]

WRITE STop      -> (l == TOP      && kk < nzz-1 && ts < nt-1) ? SBottom   UpdateStress(BOTTOM,   sc, ts, ii, jj, kk+1) [type = STOP_HALO]
WRITE SBottom   -> (l == BOTTOM   && kk > 0     && ts < nt-1) ? STop      UpdateStress(TOP,      sc, ts, ii, jj, kk-1) [type = SBOTTOM_HALO]

BODY
{
  /* fprintf(stdout, "ExtractStressHalo(%d, %d, %d, %d, %d, %d)\n", l, sc, ts, ii, jj, kk); */

  switch(l){
  case _LEFT:
    if (ii > 0 && ts < nt-1){
      ((extractStressHalo_t) extractStressHalo) (l, sc, ts, ii, jj, kk, SLeft);
    }
    break;
  case _RIGHT:
    if (ii < nxx-1 && ts < nt-1){
      ((extractStressHalo_t) extractStressHalo) (l, sc, ts, ii, jj, kk, SRight);
    }
    break;
  case _BACKWARD:
    if (jj > 0 && ts < nt-1){
      ((extractStressHalo_t) extractStressHalo) (l, sc, ts, ii, jj, kk, SBackward);
    }
    break;
  case _FORWARD:
    if (jj < nyy-1 && ts < nt-1){
      ((extractStressHalo_t) extractStressHalo) (l, sc, ts, ii, jj, kk, SForward);
    }
    break;
  case _BOTTOM:
    if (kk > 0 && ts < nt-1){
      ((extractStressHalo_t) extractStressHalo) (l, sc, ts, ii, jj, kk, SBottom);
    }
    break;
  case _TOP:
    if (kk < nzz-1 && ts < nt-1){
      ((extractStressHalo_t) extractStressHalo) (l, sc, ts, ii, jj, kk, STop);
    }
    break;
  default:
    fprintf(stdout, "ExtractStressHalo(%d, %d, %d, %d, %d, %d) - Unknown location\n", l, sc, ts, ii, jj, kk);
  }

  /* fprintf(stdout, "ExtractStressHalo(%d, %d, %d, %d, %d, %d) - Completed\n", l, sc, ts, ii, jj, kk); */
}
END


UpdateStress(l, sc, ts, ii, jj, kk)

// Execution space
l  = 0 .. nl-1
sc = 0 .. nsc-1
ts = 1 .. nt-3 .. 2
ii = 0 .. nxx-1
jj = 0 .. nyy-1
kk = 0 .. nzz-1


// Parallel partitioning
: sewas_ddesc(ii, jj, kk)


// Data flow
READ SLeft      <-  (l == LEFT     && ii > 0     && ts > 1) ? SRight    ExtractStressHalo(RIGHT, sc, ts, ii-1, jj, kk)    [type = SLEFT_HALO]
                <- !(l == LEFT     && ii > 0     && ts > 1) ? NULL
READ SRight     <-  (l == RIGHT    && ii < nxx-1 && ts > 1) ? SLeft     ExtractStressHalo(LEFT,  sc, ts, ii+1, jj, kk)    [type = SRIGHT_HALO]
                <- !(l == RIGHT    && ii < nxx-1 && ts > 1) ? NULL

READ SBackward  <-  (l == BACKWARD && jj > 0     && ts > 1) ? SForward  ExtractStressHalo(FORWARD,  sc, ts, ii, jj-1, kk) [type = SBACKWARD_HALO]
                <- !(l == BACKWARD && jj > 0     && ts > 1) ? NULL
READ SForward   <-  (l == FORWARD  && jj < nyy-1 && ts > 1) ? SBackward ExtractStressHalo(BACKWARD, sc, ts, ii, jj+1, kk) [type = SFORWARD_HALO]
                <- !(l == FORWARD  && jj < nyy-1 && ts > 1) ? NULL

READ SBottom    <-  (l == BOTTOM   && kk > 0     && ts > 1) ? STop      ExtractStressHalo(TOP,    sc, ts, ii, jj, kk-1)   [type = SBOTTOM_HALO]
                <- !(l == BOTTOM   && kk > 0     && ts > 1) ? NULL
READ STop       <-  (l == TOP      && kk < nzz-1 && ts > 1) ? SBottom   ExtractStressHalo(BOTTOM, sc, ts, ii, jj, kk+1)   [type = STOP_HALO]
                <- !(l == TOP      && kk < nzz-1 && ts > 1) ? NULL


CTL S           <- (ts > 1) ? S ExtractStressHalo(l, sc, ts, ii, jj, kk)


CTL SxxH        -> (sc == XX && ts > 1) ? SxxH ComputeVelocity(X, ts+1, ii, jj, kk)
CTL SyyH        -> (sc == YY && ts > 1) ? SyyH ComputeVelocity(Y, ts+1, ii, jj, kk)
CTL SzzH        -> (sc == ZZ && ts > 1) ? SzzH ComputeVelocity(Z, ts+1, ii, jj, kk)
CTL SxyH        -> (sc == XY && ts > 1) ? SxyH ComputeVelocity(X, ts+1, ii, jj, kk)
                -> (sc == XY && ts > 1) ? SxyH ComputeVelocity(Y, ts+1, ii, jj, kk)
CTL SxzH        -> (sc == XZ && ts > 1) ? SxzH ComputeVelocity(X, ts+1, ii, jj, kk)
                -> (sc == XZ && ts > 1) ? SxzH ComputeVelocity(Z, ts+1, ii, jj, kk)
CTL SyzH        -> (sc == YZ && ts > 1) ? SyzH ComputeVelocity(Y, ts+1, ii, jj, kk)
                -> (sc == YZ && ts > 1) ? SyzH ComputeVelocity(Z, ts+1, ii, jj, kk)

BODY
{
  /* fprintf(stdout, "UpdateStress(%d, %d, %d, %d, %d, %d)\n", l, sc, ts, ii, jj, kk); */

  switch(l){
  case _LEFT:
    if (ii > 0 && ts > 1){
      ((updateStress_t) updateStress) (l, sc, ts, ii, jj, kk, SLeft);
    }
    break;
  case _RIGHT:
    if (ii < nxx-1 && ts > 1){
      ((updateStress_t) updateStress) (l, sc, ts, ii, jj, kk, SRight);
    }
    break;
  case _BACKWARD:
    if (jj > 0 && ts > 1){
      ((updateStress_t) updateStress) (l, sc, ts, ii, jj, kk, SBackward);
    }
    break;
  case _FORWARD:
    if (jj < nyy-1 && ts > 1){
      ((updateStress_t) updateStress) (l, sc, ts, ii, jj, kk, SForward);
    }
    break;
  case _BOTTOM:
    if (kk > 0 && ts > 1){
      ((updateStress_t) updateStress) (l, sc, ts, ii, jj, kk, SBottom);
    }
    break;
  case _TOP:
    if (kk < nzz-1 && ts > 1){
      ((updateStress_t) updateStress) (l, sc, ts, ii, jj, kk, STop);
    }
    break;
  default:
    fprintf(stdout, "UpdateStress(%d, %d, %d, %d, %d, %d) - Unknown location\n", l, sc, ts, ii, jj, kk);
  }

  /* fprintf(stdout, "UpdateStress(%d, %d, %d, %d, %d, %d) - Completed\n", l, sc, ts, ii, jj, kk); */
}
END



DisplayVelocity(d, ts, ii, jj, kk)

// Execution space
d  = 0 .. dim-1
ts = 2 .. nt-2 .. 2
ii = 0 .. nxx-1
jj = 0 .. nyy-1
kk = 0 .. nzz-1


// Parallel partitioning (visualization is performed on the master process)
: sewas_ddesc(0, 0, 0)


CTL V    <- V ComputeVelocity(d, ts, ii, jj, kk)


// Priority
; (nxx-ii)*(nyy-jj)*(nzz-kk)*(nt-ts+1)


BODY
{
#ifdef VISUALIZE_EXECUTION
  fprintf(stdout, "DisplayVelocity: %d, %d, %d, %d, %d, %d\n", d, ts, ii, jj, kk, 0);

  ((displayVelocity_t) displayVelocity) (d, ts, ii, jj, kk, 0);

  fprintf(stdout, "DisplayVelocity - Completed: %d, %d, %d, %d, %d, %d\n", d, ts, ii, jj, kk, 0);
#endif
}
END



DisplayStress(sc, ts, ii, jj, kk)

// Execution space
sc = 0 .. nsc-1
ts = 3 .. nt-1 .. 2
ii = 0 .. nxx-1
jj = 0 .. nyy-1
kk = 0 .. nzz-1


// Parallel partitioning (visualization is performed on the master process)
: sewas_ddesc(0, 0, 0)


CTL S    <- S ComputeStress(sc, ts, ii, jj, kk)


// Priority
; (nxx-ii)*(nyy-jj)*(nzz-kk)*(nt-ts+1)


BODY
{
#ifdef VISUALIZE_EXECUTION
  fprintf(stdout, "DisplayStress: %d, %d, %d, %d, %d, %d\n", sc, ts, ii, jj, kk, 0);

  ((displayStress_t) displayStress) (sc, ts, ii, jj, kk, 0);

  fprintf(stdout, "DisplayStress - Completed: %d, %d, %d, %d, %d, %d\n", sc, ts, ii, jj, kk, 0);
#endif
}
END
